<?php

/*
 * This file is part of Wart.
 *
 * Copyright (c) 2014 Ulrich Kautz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Wart main class.
 *
 * Extends Pimple
 *
 * @package wart
 * @author  Ulrich Kautz
 */
class Wart extends Pimple
{
    /**
     * @var string[] List of additional namespaces
     */
    protected $namespaces;
    /**
     * @var string[] List of additional namespaces
     */
    protected $createArgs;

    /**
     * @var bool Whether auto resolving on array access is enabled
     */
    protected $autoResolve;

    /**
     * @var array List of already created instances to find circular dependencies
     */
    protected $edges;

    /**
     * @var array Mapping of service aliases
     */
    protected $aliases;

    /**
     * Instantiate the container.
     *
     * Objects and parameters and additional namespaces for auto-resolving class names can be passed as argument to the constructor.
     *
     * Config parameter are:
     *
     * * "namespaces":
     *      Array of additional namespaces to allow shortcut access (eg array("\Vendor") to allow $this["Foo"] referring to "\Vendor\Foo")
     * * "createArgs":
     *      Associative array with absolute class name and additional, tailing constructor arguments
     *      Assuming "\Vendor\Foo" has the constructor signature (\Vendor\Bar $bar, $someArg) then the following can inject $someArg:
     *          array("\Vendor\Foo" => array("The Arg Value"))
     *      Alternatively a callback for constructor arg generation can be set:
     *          array("\Vendor\Foo" => function (array $autoArgs, $className, \Wart $p) { return array_merge($autoArgs, array("Some Arg")); })
     * * "aliases":
     *      Associative array with service aliases.
     *      Can be used to resolve interfaces to implementations, e.g.:
     *          array("\Vendor\FooInterface" => "\Vendor\Foo")
     * * "autoResolve":
     *      Boolean value. If true, then class instances can be generated by access (eg $foo = $this["\Vendor\Foo"] creates and returns instances).
     *      If not enabled, instances must be created or registered beforehand. See register and create method.
     *      Default: true
     *
     * @param array $values The parameters of the object
     * @param array $config Associative array with optional "namespaces", "createArgs" and "autoResolve" keys
     */
    public function __construct(array $values = array(), array $config = array())
    {
        parent::__construct($values);
        $this->namespaces  = isset($config['namespaces']) ? $config['namespaces'] : array();
        $this->createArgs  = isset($config['createArgs']) ? $config['createArgs'] : array();
        $this->aliases     = isset($config['aliases']) ? $config['aliases'] : array();
        $this->autoResolve = isset($config['autoResolve']) ? $config['autoResolve'] : true;
        $this->edges       = array();
    }

    /**
     * @param \string[] $createArgs
     */
    public function setCreateArgs($createArgs)
    {
        $this->createArgs = $createArgs;
    }

    /**
     * @param \string[] $aliases
     */
    public function setAliases($aliases)
    {
        $this->aliases = $aliases;
    }

    /**
     * @param bool $autoResolve
     */
    public function setAutoResolve($autoResolve)
    {
        $this->autoResolve = $autoResolve;
    }

    /**
     * @param \string[] $namespaces
     */
    public function setNamespaces($namespaces)
    {
        $this->namespaces = $namespaces;
    }

    /**
     * Gets a parameter or an object. Performs
     *
     * @param string $id The unique identifier for the parameter or object
     *
     * @return mixed The value of the parameter or an object
     *
     * @throws InvalidArgumentException if the identifier is not defined
     * @throws RuntimeException         if there is a circular dependency
     */
    public function offsetGet($id)
    {
        if (!isset($this[$id]) && $this->autoResolve && ($resolvedClassName = $this->resolveClassName($id))) {
            $this->autoRegister($id);

            return $this[$id];
        } elseif (isset($this[$id]) && ($error = $this->getCircularEdgeError($id))) {
            throw new \RuntimeException($error);
        }

        return parent::offsetGet($id);
    }

    /**
     * {@inheritdoc}
     */
    public function offsetUnset($id)
    {
        parent::offsetUnset($id);
        $resolvedClass = $this->resolveClassName($id);
        $absoluteClass = $this->absoluteClassName($id);
        foreach (array($id, $absoluteClass, $resolvedClass) as $key) {
            if (isset($this->edges[$key])) {
                unset($this->edges[$key]);
            }
        }
    }

    /**
     * Manually create a new auto-resolved class instance and return it
     *
     * @param string $className Absolute class name or partial class name of registered namespaces
     * @param bool   $return
     *
     * @throws RuntimeException
     * @throws InvalidArgumentException
     * @return mixed
     */
    public function create($className, $return = true)
    {
        $origClassName = $className;
        if (!($className = $this->resolveClassName($className))) {
            throw new \InvalidArgumentException("Class \"$origClassName\" does not exist and could not be found in namespaces");
        }

        // to comply with Pimple2 -> no overwriting (user must manually unset)
        if (isset($this[$className])) {
            throw new \RuntimeException("Cannot override frozen service \"$className\"");
        } else if ($origClassName !== $className && isset($this[$origClassName])) {
            throw new \RuntimeException("Cannot override frozen service \"$origClassName\"");
        }

        $self             = $this;
        $this[$className] = function () use ($self, $className) {
            return $self->createInstance($className);
        };
        if ($origClassName !== $className) {
            $this[$origClassName] = function () use ($self, $className) {
                return $self[$className];
            };
        }

        return $return ? $this[$className] : null;
    }

    /**
     * Pre-register class instance, but do not create it (will be created on first access)
     *
     * @param string $className Absolute class name or partial class name of registered namespaces
     */
    public function autoRegister($className)
    {
        $this->create($className, false);
    }


    /**
     * Create instance of class.
     *
     * Public visibility to comply with PHP 5.3
     *
     * @param string $className Absolute class name
     *
     * @throws RuntimeException
     * @return object
     */
    public function createInstance($className)
    {
        $classReflection = new \ReflectionClass($className);
        if (!$classReflection->hasMethod('__construct')) {
            return $classReflection->newInstance();
        } else {
            $this->edges[$className] = array();
            $constructorReflection   = $classReflection->getMethod('__construct');
            $constructorArgs         = $this->generateConstructorParameters($constructorReflection, $className);
            $constructorArgs         = $this->mergeWithCreateArgs($constructorArgs, $className);

            return $classReflection->newInstanceArgs($constructorArgs);
        }
    }

    /**
     * Builds and returns signature
     *
     * @param \ReflectionMethod $methodReflection
     * @param string            $className
     *
     * @throws RuntimeException
     * @return array
     */
    protected function generateConstructorParameters(\ReflectionMethod $methodReflection, $className)
    {
        $buildArgs = array();
        foreach ($methodReflection->getParameters() as $parameterReflection) {
            if ($parameterClassReflection = $parameterReflection->getClass()) {
                $parameterClass             = $this->absoluteClassName($parameterClassReflection->getName());
                $this->edges[$className] [] = $parameterClass;
                if ($error = $this->getCircularEdgeError($parameterClass)) {
                    throw new \RuntimeException($error);
                } else {
                    $buildArgs [] = isset($this[$parameterClass]) ? $this[$parameterClass] : $this->create($parameterClass);
                }
            } else {
                break;
            }
        }

        return $buildArgs;
    }

    /**
     * Merge with create args or execute merge function
     *
     * @param array  $constructorArgs
     * @param string $className
     *
     * @throws InvalidArgumentException
     * @return array
     */
    protected function mergeWithCreateArgs(array $constructorArgs, $className)
    {
        $relativeClassName = $this->relativeClassName($className);
        $absoluteClassName = $this->absoluteClassName($className);
        $className = $this->relativeClassName($className);
        if (isset($this->createArgs[$className])) {
            $args = $this->createArgs[$className];
        } elseif (isset($this->createArgs[$relativeClassName])) {
            $args = $this->createArgs[$relativeClassName];
        } elseif (isset($this->createArgs[$absoluteClassName])) {
            $args = $this->createArgs[$absoluteClassName];
        } else {
            return $constructorArgs;
        }
        if (is_callable($args)) {
            return $args($constructorArgs, $className, $this);
        } elseif (is_array($args)) {
            return array_merge($constructorArgs, $args);
        } else {
            throw new InvalidArgumentException("Invalid create args for \"$className\". Use either array or Callable");
        }
    }

    /**
     * Checks if class exists
     *
     * @param string $className
     *
     * @return string|null
     */
    protected function resolveClassName($className)
    {
        $relativeClassName = $this->relativeClassName($className);
        $absoluteClassName = $this->absoluteClassName($className);
        if (array_key_exists($relativeClassName, $this->aliases)) {
            $className = $this->aliases[$relativeClassName];
        }
        if (array_key_exists($absoluteClassName, $this->aliases)) {
            $className = $this->aliases[$absoluteClassName];
        }
        if (class_exists($className)) {
            return $className;
        }
        foreach ($this->namespaces as $namespace) {
            $testClass = "$namespace\\$className";
            if (class_exists($testClass)) {
                return $this->absoluteClassName($testClass);
            }
        }

        return null;
    }

    /**
     * Returns absolute class name - always with leading backslash
     *
     * @param string $className
     *
     * @return string
     */
    protected function absoluteClassName($className)
    {
        return substr($className, 0, 1) === '\\' ? $className : "\\$className";
    }

    /**
     * Returns absolute class name - always with leading backslash
     *
     * @param string $className
     *
     * @return string
     */
    protected function relativeClassName($className)
    {
        return substr($className, 0, 1) === '\\' ? ltrim($className, '\\') : $className;
    }

    /**
     * Returns formatted circular edge error, if circurlar edge found. Otherwise null
     *
     * @param string $className
     *
     * @return string|null
     */
    protected function getCircularEdgeError($className)
    {
        $className = $this->absoluteClassName($className);
        if ($circle = $this->findCircularEdge($className)) {
            return "Found circular dependencies: " . implode(' => ', $circle) . " => $className";
        }

        return null;
    }

    /**
     * Finds circular dependencies and returns them
     *
     * @param string $className
     * @param array  $circle
     *
     * @return array|null
     */
    protected function findCircularEdge($className, $circle = array())
    {
        if (!isset($this->edges[$className])) {
            return null;
        }
        if (in_array($className, $circle)) {
            return $circle;
        }
        $circle [] = $className;
        foreach ($this->edges[$className] as $edge) {
            if ($inner = $this->findCircularEdge($edge, $circle)) {
                return $inner;
            }
        }

        return null;
    }
}
